using System.Linq;
using System.Text;

namespace TONL.NET.SourceGenerator;

/// <summary>
/// Generates high-performance serialization code for types marked with [TonlSerializable].
/// Uses .NET 9/10 best practices: AggressiveInlining, direct property access, zero boxing.
/// </summary>
internal static class CodeGenerator
{
    public static string GenerateSerializer(SerializableTypeInfo typeInfo)
    {
        var sb = new StringBuilder(4096);

        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using TONL.NET;");
        sb.AppendLine();

        // Namespace
        var generatedNamespace = typeInfo.Namespace != null
            ? $"{typeInfo.Namespace}.Generated"
            : "TONL.NET.Generated";

        sb.AppendLine($"namespace {generatedNamespace}");
        sb.AppendLine("{");

        // Serializer class
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Generated TONL serializer for <see cref=\"{typeInfo.FullyQualifiedName}\"/>.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static class {typeInfo.TypeName}TonlSerializer");
        sb.AppendLine("    {");

        // Property names array for tabular serialization
        GeneratePropertyNamesArray(sb, typeInfo);

        // Serialize method
        if (typeInfo.GenerateSerializer)
        {
            GenerateSerializeMethod(sb, typeInfo);
        }

        // Deserialize method
        if (typeInfo.GenerateDeserializer)
        {
            GenerateDeserializeMethod(sb, typeInfo);
        }

        // SerializeToString helper
        if (typeInfo.GenerateSerializer)
        {
            GenerateSerializeToStringMethod(sb, typeInfo);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GeneratePropertyNamesArray(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Property names for tabular serialization.");
        sb.AppendLine("        /// </summary>");
        sb.Append("        public static readonly string[] PropertyNames = [");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append($"\"{typeInfo.Properties[i].Name}\"");
        }

        sb.AppendLine("];");
        sb.AppendLine();
    }

    private static void GenerateSerializeMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Serializes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> to a dictionary.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static Dictionary<string, object?> Serialize({typeInfo.FullyQualifiedName} value)");
        sb.AppendLine("        {");

        if (typeInfo.IsValueType)
        {
            sb.AppendLine($"            var dict = new Dictionary<string, object?>({typeInfo.Properties.Length});");
        }
        else
        {
            sb.AppendLine("            if (value is null)");
            sb.AppendLine("                throw new ArgumentNullException(nameof(value));");
            sb.AppendLine();
            sb.AppendLine($"            var dict = new Dictionary<string, object?>({typeInfo.Properties.Length});");
        }

        // Generate property serialization - direct access, no reflection
        foreach (var prop in typeInfo.Properties)
        {
            var valueAccess = GetSerializeValueAccess(prop);
            sb.AppendLine($"            dict[\"{prop.Name}\"] = {valueAccess};");
        }

        sb.AppendLine("            return dict;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string GetSerializeValueAccess(PropertyInfo prop)
    {
        var access = $"value.{prop.Name}";

        return prop.Category switch
        {
            PropertyCategory.Enum => $"(int){access}",
            PropertyCategory.DateTime => $"{access}.ToString(\"O\")",
            PropertyCategory.Guid => $"{access}.ToString()",
            PropertyCategory.TimeSpan => $"{access}.ToString()",
            _ => access
        };
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Deserializes a dictionary to <see cref=\"{typeInfo.FullyQualifiedName}\"/>.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static {typeInfo.FullyQualifiedName} Deserialize(Dictionary<string, object?> dict)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (dict is null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(dict));");
        sb.AppendLine();

        if (typeInfo.IsRecord && typeInfo.Properties.Length > 0)
        {
            // Records: use primary constructor
            GenerateRecordDeserialization(sb, typeInfo);
        }
        else if (typeInfo.Properties.All(p => p.HasPublicSetter))
        {
            // POCOs: use object initializer
            GeneratePocoDeserialization(sb, typeInfo);
        }
        else
        {
            // Mixed: set what we can
            GenerateMixedDeserialization(sb, typeInfo);
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateRecordDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            return new {typeInfo.FullyQualifiedName}(");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var comma = i < typeInfo.Properties.Length - 1 ? "," : ");";
            var conversion = GetDeserializeConversion(prop);
            sb.AppendLine($"                {conversion}{comma}");
        }
    }

    private static void GeneratePocoDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            return new {typeInfo.FullyQualifiedName}");
        sb.AppendLine("            {");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var comma = i < typeInfo.Properties.Length - 1 ? "," : "";
            var conversion = GetDeserializeConversion(prop);
            sb.AppendLine($"                {prop.Name} = {conversion}{comma}");
        }

        sb.AppendLine("            };");
    }

    private static void GenerateMixedDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            var result = new {typeInfo.FullyQualifiedName}();");

        foreach (var prop in typeInfo.Properties.Where(p => p.HasPublicSetter))
        {
            var conversion = GetDeserializeConversion(prop);
            sb.AppendLine($"            result.{prop.Name} = {conversion};");
        }

        sb.AppendLine("            return result;");
    }

    private static string GetDeserializeConversion(PropertyInfo prop)
    {
        var dictAccess = $"dict[\"{prop.Name}\"]";
        var baseType = prop.TypeName.TrimEnd('?');

        return prop.Category switch
        {
            PropertyCategory.Boolean => GetTypedConversion(dictAccess, "bool", prop.IsNullable),
            PropertyCategory.Integer => GetNumericConversion(dictAccess, baseType, prop.IsNullable),
            PropertyCategory.Float => GetNumericConversion(dictAccess, baseType, prop.IsNullable),
            PropertyCategory.Decimal => GetTypedConversion(dictAccess, "decimal", prop.IsNullable),
            PropertyCategory.String => prop.IsNullable ? $"{dictAccess} as string" : $"({dictAccess} as string)!",
            PropertyCategory.DateTime => GetDateTimeConversion(dictAccess, baseType, prop.IsNullable),
            PropertyCategory.Guid => GetGuidConversion(dictAccess, prop.IsNullable),
            PropertyCategory.TimeSpan => GetTimeSpanConversion(dictAccess, prop.IsNullable),
            PropertyCategory.Enum => GetEnumConversion(dictAccess, baseType, prop.IsNullable),
            _ => $"({prop.TypeName}){dictAccess}"
        };
    }

    private static string GetTypedConversion(string dictAccess, string typeName, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is {typeName} v ? v : null";
        return $"({typeName}){dictAccess}!";
    }

    private static string GetNumericConversion(string dictAccess, string typeName, bool isNullable)
    {
        // Handle numeric conversions from various source types
        var cast = typeName switch
        {
            "global::System.Int32" or "int" => "int",
            "global::System.Int64" or "long" => "long",
            "global::System.Double" or "double" => "double",
            "global::System.Single" or "float" => "float",
            "global::System.Decimal" or "decimal" => "decimal",
            "global::System.Int16" or "short" => "short",
            "global::System.Byte" or "byte" => "byte",
            _ => typeName.Replace("global::", "")
        };

        if (isNullable)
            return $"{dictAccess} is {cast} n ? n : null";
        return $"Convert.To{GetConvertMethodName(cast)}({dictAccess})";
    }

    private static string GetConvertMethodName(string typeName)
    {
        return typeName switch
        {
            "int" => "Int32",
            "long" => "Int64",
            "double" => "Double",
            "float" => "Single",
            "decimal" => "Decimal",
            "short" => "Int16",
            "byte" => "Byte",
            _ => typeName
        };
    }

    private static string GetDateTimeConversion(string dictAccess, string typeName, bool isNullable)
    {
        var parseMethod = typeName.Contains("DateTimeOffset") ? "DateTimeOffset.Parse" : "DateTime.Parse";

        if (isNullable)
            return $"{dictAccess} is string s ? {parseMethod}(s) : null";
        return $"{parseMethod}(({dictAccess} as string)!)";
    }

    private static string GetGuidConversion(string dictAccess, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is string s ? Guid.Parse(s) : null";
        return $"Guid.Parse({dictAccess}?.ToString() ?? throw new InvalidOperationException(\"Guid value is null\"))";
    }

    private static string GetTimeSpanConversion(string dictAccess, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is string s ? TimeSpan.Parse(s) : null";
        return $"TimeSpan.Parse(({dictAccess} as string)!)";
    }

    private static string GetEnumConversion(string dictAccess, string typeName, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is int i ? ({typeName})i : null";
        return $"({typeName})(int){dictAccess}!";
    }

    private static void GenerateSerializeToStringMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Serializes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> to a TONL string.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static string SerializeToString({typeInfo.FullyQualifiedName} value, TonlOptions? options = null)");
        sb.AppendLine("        {");
        sb.AppendLine("            var dict = Serialize(value);");
        sb.AppendLine("            return TonlSerializer.SerializeToString(dict, options);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }
}
