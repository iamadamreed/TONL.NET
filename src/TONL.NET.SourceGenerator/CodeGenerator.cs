using System.Linq;
using System.Text;

namespace TONL.NET.SourceGenerator;

/// <summary>
/// Generates high-performance serialization code for types marked with [TonlSerializable].
/// Uses .NET 9/10 best practices: AggressiveInlining, direct property access, zero boxing.
/// </summary>
internal static class CodeGenerator
{
    public static string GenerateSerializer(SerializableTypeInfo typeInfo)
    {
        var sb = new StringBuilder(4096);

        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using TONL.NET;");
        sb.AppendLine();

        // Namespace
        var generatedNamespace = typeInfo.Namespace != null
            ? $"{typeInfo.Namespace}.Generated"
            : "TONL.NET.Generated";

        sb.AppendLine($"namespace {generatedNamespace}");
        sb.AppendLine("{");

        // Serializer class
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Generated TONL serializer for <see cref=\"{typeInfo.FullyQualifiedName}\"/>.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static class {typeInfo.TypeName}TonlSerializer");
        sb.AppendLine("    {");

        // Property names array for tabular serialization
        GeneratePropertyNamesArray(sb, typeInfo);

        // Serialize method
        if (typeInfo.GenerateSerializer)
        {
            GenerateSerializeMethod(sb, typeInfo);
        }

        // Deserialize method
        if (typeInfo.GenerateDeserializer)
        {
            GenerateDeserializeMethod(sb, typeInfo);
        }

        // SerializeToString helper
        if (typeInfo.GenerateSerializer)
        {
            GenerateSerializeToStringMethod(sb, typeInfo);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GeneratePropertyNamesArray(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Property names for tabular serialization.");
        sb.AppendLine("        /// </summary>");
        sb.Append("        public static readonly string[] PropertyNames = [");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append($"\"{typeInfo.Properties[i].Name}\"");
        }

        sb.AppendLine("];");
        sb.AppendLine();
    }

    private static void GenerateSerializeMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Serializes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> to a dictionary.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static Dictionary<string, object?> Serialize({typeInfo.FullyQualifiedName} value)");
        sb.AppendLine("        {");

        if (typeInfo.IsValueType)
        {
            sb.AppendLine($"            var dict = new Dictionary<string, object?>({typeInfo.Properties.Length});");
        }
        else
        {
            sb.AppendLine("            if (value is null)");
            sb.AppendLine("                throw new ArgumentNullException(nameof(value));");
            sb.AppendLine();
            sb.AppendLine($"            var dict = new Dictionary<string, object?>({typeInfo.Properties.Length});");
        }

        // Generate property serialization - direct access, no reflection
        foreach (var prop in typeInfo.Properties)
        {
            var valueAccess = GetSerializeValueAccess(prop);
            sb.AppendLine($"            dict[\"{prop.Name}\"] = {valueAccess};");
        }

        sb.AppendLine("            return dict;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string GetSerializeValueAccess(PropertyInfo prop)
    {
        var access = $"value.{prop.Name}";

        return prop.Category switch
        {
            PropertyCategory.Enum => $"Convert.ToInt64({access})", // Use Int64 to handle all enum underlying types
            PropertyCategory.DateTime => $"{access}.ToString(\"O\")",
            PropertyCategory.Guid => $"{access}.ToString()",
            PropertyCategory.TimeSpan => $"{access}.ToString()",
            _ => access
        };
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Deserializes a dictionary to <see cref=\"{typeInfo.FullyQualifiedName}\"/>.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static {typeInfo.FullyQualifiedName} Deserialize(Dictionary<string, object?> dict)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (dict is null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(dict));");
        sb.AppendLine();

        if (typeInfo.IsRecord && typeInfo.Properties.Length > 0)
        {
            // Records: use primary constructor
            GenerateRecordDeserialization(sb, typeInfo);
        }
        else if (typeInfo.Properties.All(p => p.HasPublicSetter))
        {
            // POCOs: use object initializer
            GeneratePocoDeserialization(sb, typeInfo);
        }
        else
        {
            // Mixed: set what we can
            GenerateMixedDeserialization(sb, typeInfo);
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateRecordDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            return new {typeInfo.FullyQualifiedName}(");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var comma = i < typeInfo.Properties.Length - 1 ? "," : ");";
            var conversion = GetDeserializeConversion(prop);
            sb.AppendLine($"                {conversion}{comma}");
        }
    }

    private static void GeneratePocoDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            return new {typeInfo.FullyQualifiedName}");
        sb.AppendLine("            {");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var comma = i < typeInfo.Properties.Length - 1 ? "," : "";
            var conversion = GetDeserializeConversion(prop);
            sb.AppendLine($"                {prop.Name} = {conversion}{comma}");
        }

        sb.AppendLine("            };");
    }

    private static void GenerateMixedDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            var result = new {typeInfo.FullyQualifiedName}();");

        foreach (var prop in typeInfo.Properties.Where(p => p.HasPublicSetter))
        {
            var conversion = GetDeserializeConversion(prop);
            sb.AppendLine($"            result.{prop.Name} = {conversion};");
        }

        sb.AppendLine("            return result;");
    }

    private static string GetDeserializeConversion(PropertyInfo prop)
    {
        var dictAccess = $"dict[\"{prop.Name}\"]";
        var baseType = prop.TypeName.TrimEnd('?');

        return prop.Category switch
        {
            PropertyCategory.Boolean => GetTypedConversion(dictAccess, "bool", prop.IsNullable),
            PropertyCategory.Integer => GetNumericConversion(dictAccess, baseType, prop.IsNullable),
            PropertyCategory.Float => GetNumericConversion(dictAccess, baseType, prop.IsNullable),
            PropertyCategory.Decimal => GetTypedConversion(dictAccess, "decimal", prop.IsNullable),
            PropertyCategory.String => prop.IsNullable ? $"{dictAccess} as string" : $"({dictAccess} as string)!",
            PropertyCategory.DateTime => GetDateTimeConversion(dictAccess, baseType, prop.IsNullable),
            PropertyCategory.Guid => GetGuidConversion(dictAccess, prop.IsNullable),
            PropertyCategory.TimeSpan => GetTimeSpanConversion(dictAccess, prop.IsNullable),
            PropertyCategory.Enum => GetEnumConversion(dictAccess, baseType, prop.IsNullable),
            _ => $"({prop.TypeName}){dictAccess}"
        };
    }

    private static string GetTypedConversion(string dictAccess, string typeName, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is {typeName} v ? v : null";
        return $"({typeName}){dictAccess}!";
    }

    private static string GetNumericConversion(string dictAccess, string typeName, bool isNullable)
    {
        // Handle numeric conversions from various source types
        var cast = typeName switch
        {
            "global::System.Int32" or "int" => "int",
            "global::System.Int64" or "long" => "long",
            "global::System.Double" or "double" => "double",
            "global::System.Single" or "float" => "float",
            "global::System.Decimal" or "decimal" => "decimal",
            "global::System.Int16" or "short" => "short",
            "global::System.Byte" or "byte" => "byte",
            _ => typeName.Replace("global::", "")
        };

        if (isNullable)
            return $"{dictAccess} is {cast} n ? n : null";
        return $"Convert.To{GetConvertMethodName(cast)}({dictAccess})";
    }

    private static string GetConvertMethodName(string typeName)
    {
        return typeName switch
        {
            "int" => "Int32",
            "long" => "Int64",
            "double" => "Double",
            "float" => "Single",
            "decimal" => "Decimal",
            "short" => "Int16",
            "byte" => "Byte",
            _ => typeName
        };
    }

    private static string GetDateTimeConversion(string dictAccess, string typeName, bool isNullable)
    {
        var parseMethod = typeName.Contains("DateTimeOffset") ? "DateTimeOffset.Parse" : "DateTime.Parse";

        if (isNullable)
            return $"{dictAccess} is string s ? {parseMethod}(s) : null";
        return $"{parseMethod}(({dictAccess} as string)!)";
    }

    private static string GetGuidConversion(string dictAccess, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is string s ? Guid.Parse(s) : null";
        return $"Guid.Parse({dictAccess}?.ToString() ?? throw new InvalidOperationException(\"Guid value is null\"))";
    }

    private static string GetTimeSpanConversion(string dictAccess, bool isNullable)
    {
        if (isNullable)
            return $"{dictAccess} is string s ? TimeSpan.Parse(s) : null";
        return $"TimeSpan.Parse(({dictAccess} as string)!)";
    }

    private static string GetEnumConversion(string dictAccess, string typeName, bool isNullable)
    {
        // Handle both int and long since we serialize enums as Int64
        if (isNullable)
            return $"{dictAccess} is long l ? ({typeName})l : ({dictAccess} is int i ? ({typeName})i : null)";
        return $"({typeName})Convert.ToInt64({dictAccess})";
    }

    private static void GenerateSerializeToStringMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Serializes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> to a TONL string.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static string SerializeToString({typeInfo.FullyQualifiedName} value, TonlOptions? options = null)");
        sb.AppendLine("        {");
        sb.AppendLine("            var dict = Serialize(value);");
        sb.AppendLine("            return TonlSerializer.SerializeToString(dict, options);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates a TonlSerializerContext partial class with type info properties.
    /// </summary>
    public static string GenerateContext(ContextInfo contextInfo)
    {
        var sb = new StringBuilder(8192);

        // Filter out primitive types - they should be handled by core serialization
        var types = contextInfo.Types.Where(t => !t.IsPrimitive).ToList();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using TONL.NET;");
        sb.AppendLine();

        if (contextInfo.Namespace != null)
        {
            sb.AppendLine($"namespace {contextInfo.Namespace}");
            sb.AppendLine("{");
        }

        var indent = contextInfo.Namespace != null ? "    " : "";

        sb.AppendLine($"{indent}public partial class {contextInfo.ContextName}");
        sb.AppendLine($"{indent}{{");

        // Default singleton
        sb.AppendLine($"{indent}    private static {contextInfo.ContextName}? _default;");
        sb.AppendLine($"{indent}    public static {contextInfo.ContextName} Default => _default ??= new {contextInfo.ContextName}();");
        sb.AppendLine();

        // Type info backing fields and properties (exclude primitives)
        foreach (var type in types)
        {
            sb.AppendLine($"{indent}    private TonlTypeInfo<{type.FullyQualifiedName}>? _{type.SafePropertyName};");
            sb.AppendLine($"{indent}    public TonlTypeInfo<{type.FullyQualifiedName}> {type.SafePropertyName} => _{type.SafePropertyName} ??= Create{type.SafePropertyName}TypeInfo();");
            sb.AppendLine();
        }

        // GetTypeInfo override
        sb.AppendLine($"{indent}    public override TonlTypeInfo? GetTypeInfo(Type type)");
        sb.AppendLine($"{indent}    {{");
        foreach (var type in types)
        {
            sb.AppendLine($"{indent}        if (type == typeof({type.FullyQualifiedName})) return {type.SafePropertyName};");
        }
        sb.AppendLine($"{indent}        return null;");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // CreateXxxTypeInfo methods
        foreach (var type in types)
        {
            GenerateCreateTypeInfoMethod(sb, type, contextInfo.GenerationMode, indent);
        }

        sb.AppendLine($"{indent}}}");

        if (contextInfo.Namespace != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void GenerateCreateTypeInfoMethod(
        StringBuilder sb,
        SerializableTypeInfo type,
        TonlSourceGenerationMode mode,
        string indent)
    {
        sb.AppendLine($"{indent}    private TonlTypeInfo<{type.FullyQualifiedName}> Create{type.SafePropertyName}TypeInfo()");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        return new TonlTypeInfo<{type.FullyQualifiedName}>");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            OriginatingContext = this,");

        // Generate fast-path serialize handler
        if (mode == TonlSourceGenerationMode.Default || mode == TonlSourceGenerationMode.Serialization)
        {
            GenerateFastPathSerializer(sb, type, indent);
        }

        // Generate metadata for deserialization
        if (mode == TonlSourceGenerationMode.Default || mode == TonlSourceGenerationMode.Metadata)
        {
            GenerateMetadata(sb, type, indent);
        }

        sb.AppendLine($"{indent}        }};");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();
    }

    private static void GenerateFastPathSerializer(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        sb.AppendLine($"{indent}            Serialize = static (ref TonlWriter writer, {type.FullyQualifiedName} value) =>");
        sb.AppendLine($"{indent}            {{");

        if (!type.IsValueType)
        {
            sb.AppendLine($"{indent}                if (value is null) return;");
        }

        foreach (var prop in type.Properties)
        {
            GeneratePropertyWrite(sb, prop, indent);
        }

        sb.AppendLine($"{indent}            }},");
    }

    private static void GeneratePropertyWrite(StringBuilder sb, PropertyInfo prop, string indent)
    {
        var access = $"value.{prop.Name}";

        sb.AppendLine($"{indent}                writer.WriteIndent(1);");

        if (prop.IsNullable && prop.Category != PropertyCategory.String)
        {
            sb.AppendLine($"{indent}                if ({access} is null)");
            sb.AppendLine($"{indent}                    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{indent}                else");
            sb.Append($"{indent}                    ");
            GeneratePropertyWriteCall(sb, prop, $"{access}.Value");
        }
        else if (prop.Category == PropertyCategory.String && prop.IsNullable)
        {
            sb.AppendLine($"{indent}                if ({access} is null)");
            sb.AppendLine($"{indent}                    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{indent}                else");
            sb.Append($"{indent}                    ");
            GeneratePropertyWriteCall(sb, prop, access);
        }
        else
        {
            sb.Append($"{indent}                ");
            GeneratePropertyWriteCall(sb, prop, access);
        }

        sb.AppendLine($"{indent}                writer.WriteNewLine();");
    }

    private static void GeneratePropertyWriteCall(StringBuilder sb, PropertyInfo prop, string access)
    {
        switch (prop.Category)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"writer.WriteKeyBoolean(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.Integer:
                // Handle all integer types appropriately
                if (prop.TypeName.Contains("UInt64") || prop.TypeName.Contains("ulong"))
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());"); // ulong as string to preserve full range
                else if (prop.TypeName.Contains("Int64") || prop.TypeName.Contains("long"))
                    sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", {access});");
                else if (prop.TypeName.Contains("UInt32") || prop.TypeName.Contains("uint"))
                    sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", {access});"); // uint fits in long
                else
                    sb.AppendLine($"writer.WriteKeyInt32(\"{prop.Name}\", (int){access});");
                break;
            case PropertyCategory.Float:
                // Use proper float/double/decimal methods to preserve precision
                if (prop.TypeName.Contains("Single") || prop.TypeName.Contains("float"))
                    sb.AppendLine($"writer.WriteKeyFloat(\"{prop.Name}\", {access});");
                else
                    sb.AppendLine($"writer.WriteKeyDouble(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"writer.WriteKeyDecimal(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.String:
                // Handle char vs string
                if (prop.TypeName.Contains("Char") || prop.TypeName == "char")
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                else
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                break;
            case PropertyCategory.Enum:
                // Use Int64 to safely handle all enum underlying types (byte, sbyte, short, ushort, int, uint, long)
                // Note: ulong-backed enums with values > long.MaxValue are not supported
                sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", Convert.ToInt64({access}));");
                break;
            default:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}?.ToString() ?? \"\");");
                break;
        }
    }

    private static void GenerateMetadata(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        // Only generate CreateObject for types that can be instantiated with new T()
        // Skip for: records, interfaces, abstract classes, primitives, types without parameterless constructor,
        // and types with init-only or required properties (since those require object initializer syntax)
        if (type.CanInstantiate && !type.IsRecord && !type.HasInitOnlyProperties)
        {
            sb.AppendLine($"{indent}            CreateObject = static () => new {type.FullyQualifiedName}(),");
        }

        sb.AppendLine($"{indent}            Properties = new TonlPropertyInfo<{type.FullyQualifiedName}>[]");
        sb.AppendLine($"{indent}            {{");

        for (int i = 0; i < type.Properties.Length; i++)
        {
            var prop = type.Properties[i];
            var comma = i < type.Properties.Length - 1 ? "," : "";

            sb.AppendLine($"{indent}                new TonlPropertyInfo<{type.FullyQualifiedName}>");
            sb.AppendLine($"{indent}                {{");
            sb.AppendLine($"{indent}                    Name = \"{prop.Name}\",");
            sb.AppendLine($"{indent}                    PropertyType = typeof({prop.TypeName}),");
            sb.AppendLine($"{indent}                    IsNullable = {(prop.IsNullable ? "true" : "false")},");
            sb.AppendLine($"{indent}                    GetValue = static obj => obj.{prop.Name},");

            // Skip SetValue for:
            // - Records (init-only via primary constructor)
            // - Init-only properties (can only be set in object initializer)
            // - Required properties (must be set in object initializer)
            // - Properties without public setter
            if (prop.HasPublicSetter && !type.IsRecord && !prop.IsInitOnly && !prop.IsRequired)
            {
                var setter = GetPropertySetter(prop);
                sb.AppendLine($"{indent}                    SetValue = static (obj, val) => obj.{prop.Name} = {setter},");
            }

            sb.AppendLine($"{indent}                }}{comma}");
        }

        sb.AppendLine($"{indent}            }},");
    }

    private static string GetPropertySetter(PropertyInfo prop)
    {
        return prop.Category switch
        {
            PropertyCategory.Boolean => "val is bool b ? b : default",
            PropertyCategory.Integer => GetNumericSetter(prop.TypeName),
            PropertyCategory.Float => GetNumericSetter(prop.TypeName),
            PropertyCategory.Decimal => "val is decimal d ? d : Convert.ToDecimal(val)",
            PropertyCategory.String => prop.IsNullable ? "val as string" : "(val as string)!",
            PropertyCategory.DateTime => GetDateTimeSetter(prop.TypeName, prop.IsNullable),
            PropertyCategory.Guid => "val is string s ? Guid.Parse(s) : (Guid)(val ?? default(Guid))",
            PropertyCategory.TimeSpan => "val is string s ? TimeSpan.Parse(s) : (TimeSpan)(val ?? default(TimeSpan))",
            PropertyCategory.Enum => $"({prop.TypeName})(val is long l ? l : (val is int i ? i : Convert.ToInt64(val)))",
            _ => $"({prop.TypeName})val!"
        };
    }

    private static string GetNumericSetter(string typeName)
    {
        var convertMethod = typeName switch
        {
            "global::System.Int32" or "int" => "ToInt32",
            "global::System.Int64" or "long" => "ToInt64",
            "global::System.Double" or "double" => "ToDouble",
            "global::System.Single" or "float" => "ToSingle",
            "global::System.Decimal" or "decimal" => "ToDecimal",
            "global::System.Int16" or "short" => "ToInt16",
            "global::System.Byte" or "byte" => "ToByte",
            _ => "ToInt32"
        };

        return $"Convert.{convertMethod}(val)";
    }

    private static string GetDateTimeSetter(string typeName, bool isNullable)
    {
        var parseMethod = typeName.Contains("DateTimeOffset") ? "DateTimeOffset.Parse" : "DateTime.Parse";
        if (isNullable)
            return $"val is string s ? {parseMethod}(s) : null";
        return $"{parseMethod}((val as string)!)";
    }
}
