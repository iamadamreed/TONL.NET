using System.Linq;
using System.Text;

namespace TONL.NET.SourceGenerator;

/// <summary>
/// Generates high-performance serialization code for types marked with [TonlSerializable].
/// Uses .NET 9/10 best practices: AggressiveInlining, direct property access, zero boxing.
/// </summary>
internal static class CodeGenerator
{
    public static string GenerateSerializer(SerializableTypeInfo typeInfo)
    {
        var sb = new StringBuilder(4096);

        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using TONL.NET;");
        sb.AppendLine();

        // Namespace
        var generatedNamespace = typeInfo.Namespace != null
            ? $"{typeInfo.Namespace}.Generated"
            : "TONL.NET.Generated";

        sb.AppendLine($"namespace {generatedNamespace}");
        sb.AppendLine("{");

        // Serializer class
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Generated TONL serializer for <see cref=\"{typeInfo.FullyQualifiedName}\"/>.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine($"    public static class {typeInfo.SafePropertyName}TonlSerializer");
        sb.AppendLine("    {");

        // Property names array for tabular serialization
        GeneratePropertyNamesArray(sb, typeInfo);

        // Serialize method
        if (typeInfo.GenerateSerializer)
        {
            GenerateSerializeMethod(sb, typeInfo);
        }

        // Deserialize method - only if the type can be instantiated or is a record (uses primary constructor)
        if (typeInfo.GenerateDeserializer && (typeInfo.CanInstantiate || typeInfo.IsRecord))
        {
            GenerateDeserializeMethod(sb, typeInfo);
        }

        // SerializeToString helper
        if (typeInfo.GenerateSerializer)
        {
            GenerateSerializeToStringMethod(sb, typeInfo);

            // WriteProperties helper for nested object serialization
            GenerateWritePropertiesMethod(sb, typeInfo);

            // WriteRow helper for array/list element serialization
            GenerateWriteRowMethod(sb, typeInfo);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GeneratePropertyNamesArray(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Property names for tabular serialization.");
        sb.AppendLine("        /// </summary>");
        sb.Append("        public static readonly string[] PropertyNames = [");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append($"\"{typeInfo.Properties[i].Name}\"");
        }

        sb.AppendLine("];");
        sb.AppendLine();
    }

    private static void GenerateSerializeMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Serializes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> to a dictionary.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static Dictionary<string, object?> Serialize({typeInfo.FullyQualifiedName} value)");
        sb.AppendLine("        {");

        if (typeInfo.IsValueType)
        {
            sb.AppendLine($"            var dict = new Dictionary<string, object?>({typeInfo.Properties.Length});");
        }
        else
        {
            sb.AppendLine("            if (value is null)");
            sb.AppendLine("                throw new ArgumentNullException(nameof(value));");
            sb.AppendLine();
            sb.AppendLine($"            var dict = new Dictionary<string, object?>({typeInfo.Properties.Length});");
        }

        // Generate property serialization - direct access, no reflection
        foreach (var prop in typeInfo.Properties)
        {
            var valueAccess = GetSerializeValueAccess(prop);
            sb.AppendLine($"            dict[\"{prop.Name}\"] = {valueAccess};");
        }

        sb.AppendLine("            return dict;");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string GetSerializeValueAccess(PropertyInfo prop)
    {
        var access = $"value.{prop.Name}";

        // For nullable value types, we need to handle them differently
        // The dictionary can store null directly, but for formatting we need .Value
        if (prop.IsNullable)
        {
            return prop.Category switch
            {
                PropertyCategory.Enum => $"{access} is not null ? (object?)Convert.ToInt64({access}.Value) : null",
                PropertyCategory.DateTime => $"{access}?.ToString(\"O\")",
                PropertyCategory.Guid => $"{access}?.ToString()",
                PropertyCategory.TimeSpan => $"{access}?.ToString()",
                _ => access
            };
        }

        return prop.Category switch
        {
            PropertyCategory.Enum => $"Convert.ToInt64({access})", // Use Int64 to handle all enum underlying types
            PropertyCategory.DateTime => $"{access}.ToString(\"O\")",
            PropertyCategory.Guid => $"{access}.ToString()",
            PropertyCategory.TimeSpan => $"{access}.ToString()",
            _ => access
        };
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Deserializes a dictionary to <see cref=\"{typeInfo.FullyQualifiedName}\"/>.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static {typeInfo.FullyQualifiedName} Deserialize(Dictionary<string, object?> dict)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (dict is null)");
        sb.AppendLine("                throw new ArgumentNullException(nameof(dict));");
        sb.AppendLine();

        if (typeInfo.IsRecord && typeInfo.Properties.Length > 0)
        {
            // Records: use primary constructor
            GenerateRecordDeserialization(sb, typeInfo);
        }
        else if (typeInfo.Properties.All(p => p.HasPublicSetter))
        {
            // POCOs: use object initializer
            GeneratePocoDeserialization(sb, typeInfo);
        }
        else
        {
            // Mixed: set what we can
            GenerateMixedDeserialization(sb, typeInfo);
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateRecordDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            return new {typeInfo.FullyQualifiedName}(");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var comma = i < typeInfo.Properties.Length - 1 ? "," : ");";
            var conversion = GetDeserializeConversion(prop, i);
            sb.AppendLine($"                {conversion}{comma}");
        }
    }

    private static void GeneratePocoDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            return new {typeInfo.FullyQualifiedName}");
        sb.AppendLine("            {");

        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var comma = i < typeInfo.Properties.Length - 1 ? "," : "";
            var conversion = GetDeserializeConversion(prop, i);
            sb.AppendLine($"                {prop.Name} = {conversion}{comma}");
        }

        sb.AppendLine("            };");
    }

    private static void GenerateMixedDeserialization(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine($"            var result = new {typeInfo.FullyQualifiedName}();");

        var settableProps = typeInfo.Properties.Where(p => p.HasPublicSetter).ToArray();
        for (int i = 0; i < settableProps.Length; i++)
        {
            var prop = settableProps[i];
            var conversion = GetDeserializeConversion(prop, i);
            sb.AppendLine($"            result.{prop.Name} = {conversion};");
        }

        sb.AppendLine("            return result;");
    }

    private static string GetDeserializeConversion(PropertyInfo prop, int index)
    {
        var dictAccess = $"dict[\"{prop.Name}\"]";
        var baseType = prop.TypeName.TrimEnd('?');

        // Special case for char - categorized as String but needs extraction
        if (prop.TypeName.Contains("Char") || prop.TypeName == "char")
        {
            return prop.IsNullable
                ? $"{dictAccess} is string s{index} && s{index}.Length > 0 ? s{index}[0] : null"
                : $"({dictAccess} as string)?[0] ?? default";
        }

        return prop.Category switch
        {
            PropertyCategory.Boolean => GetTypedConversion(dictAccess, "bool", prop.IsNullable, index),
            PropertyCategory.Integer => GetNumericConversion(dictAccess, baseType, prop.IsNullable, index),
            PropertyCategory.Float => GetNumericConversion(dictAccess, baseType, prop.IsNullable, index),
            PropertyCategory.Decimal => GetTypedConversion(dictAccess, "decimal", prop.IsNullable, index),
            PropertyCategory.String => prop.IsNullable ? $"{dictAccess} as string" : $"({dictAccess} as string)!",
            PropertyCategory.DateTime => GetDateTimeConversion(dictAccess, baseType, prop.IsNullable, index),
            PropertyCategory.Guid => GetGuidConversion(dictAccess, prop.IsNullable, index),
            PropertyCategory.TimeSpan => GetTimeSpanConversion(dictAccess, prop.IsNullable, index),
            PropertyCategory.Enum => GetEnumConversion(dictAccess, baseType, prop.IsNullable, index),
            _ => $"({prop.TypeName}){dictAccess}"
        };
    }

    private static string GetTypedConversion(string dictAccess, string typeName, bool isNullable, int index)
    {
        if (isNullable)
            return $"{dictAccess} is {typeName} v{index} ? v{index} : null";
        return $"({typeName}){dictAccess}!";
    }

    private static string GetNumericConversion(string dictAccess, string typeName, bool isNullable, int index)
    {
        // Handle numeric conversions from various source types
        var cast = typeName switch
        {
            "global::System.Int32" or "int" => "int",
            "global::System.Int64" or "long" => "long",
            "global::System.Double" or "double" => "double",
            "global::System.Single" or "float" => "float",
            "global::System.Decimal" or "decimal" => "decimal",
            "global::System.Int16" or "short" => "short",
            "global::System.Byte" or "byte" => "byte",
            "global::System.SByte" or "sbyte" => "sbyte",
            "global::System.UInt16" or "ushort" => "ushort",
            "global::System.UInt32" or "uint" => "uint",
            "global::System.UInt64" or "ulong" => "ulong",
            _ => typeName.Replace("global::", "")
        };

        if (isNullable)
            return $"{dictAccess} is {cast} n{index} ? n{index} : null";
        return $"Convert.To{GetConvertMethodName(cast)}({dictAccess})";
    }

    private static string GetConvertMethodName(string typeName)
    {
        return typeName switch
        {
            "int" => "Int32",
            "long" => "Int64",
            "double" => "Double",
            "float" => "Single",
            "decimal" => "Decimal",
            "short" => "Int16",
            "byte" => "Byte",
            "sbyte" => "SByte",
            "ushort" => "UInt16",
            "uint" => "UInt32",
            "ulong" => "UInt64",
            _ => typeName
        };
    }

    private static string GetDateTimeConversion(string dictAccess, string typeName, bool isNullable, int index)
    {
        var parseMethod = typeName.Contains("DateTimeOffset") ? "DateTimeOffset.Parse" : "DateTime.Parse";

        if (isNullable)
            return $"{dictAccess} is string s{index} ? {parseMethod}(s{index}) : null";
        return $"{parseMethod}(({dictAccess} as string)!)";
    }

    private static string GetGuidConversion(string dictAccess, bool isNullable, int index)
    {
        if (isNullable)
            return $"{dictAccess} is string s{index} ? Guid.Parse(s{index}) : null";
        return $"Guid.Parse({dictAccess}?.ToString() ?? throw new InvalidOperationException(\"Guid value is null\"))";
    }

    private static string GetTimeSpanConversion(string dictAccess, bool isNullable, int index)
    {
        if (isNullable)
            return $"{dictAccess} is string s{index} ? TimeSpan.Parse(s{index}) : null";
        return $"TimeSpan.Parse(({dictAccess} as string)!)";
    }

    private static string GetEnumConversion(string dictAccess, string typeName, bool isNullable, int index)
    {
        // Handle both int and long since we serialize enums as Int64
        if (isNullable)
            return $"{dictAccess} is long l{index} ? ({typeName})l{index} : ({dictAccess} is int i{index} ? ({typeName})i{index} : null)";
        return $"({typeName})Convert.ToInt64({dictAccess})";
    }

    private static void GenerateSerializeToStringMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Serializes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> to a TONL string.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static string SerializeToString({typeInfo.FullyQualifiedName} value, TonlOptions? options = null)");
        sb.AppendLine("        {");
        sb.AppendLine("            using var bufferWriter = new TonlBufferWriter();");
        sb.AppendLine("            var writer = new TonlWriter(bufferWriter, options ?? TonlOptions.Default);");

        // Write properties at indent level 1 (top-level)
        if (!typeInfo.IsValueType)
        {
            sb.AppendLine("            if (value is null) return string.Empty;");
        }

        foreach (var prop in typeInfo.Properties)
        {
            GeneratePropertyWriteForTopLevel(sb, prop, "value");
        }

        sb.AppendLine("            writer.Flush();");
        sb.AppendLine("            return bufferWriter.ToString();");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GeneratePropertyWriteForTopLevel(StringBuilder sb, PropertyInfo prop, string valuePrefix)
    {
        var access = $"{valuePrefix}.{prop.Name}";

        // Handle collection and object properties specially - they need multi-line code blocks
        if (prop.Category == PropertyCategory.Collection)
        {
            GenerateCollectionWriteForTopLevel(sb, prop, access, indentLevel: 1);
            return;
        }
        if (prop.Category == PropertyCategory.Object)
        {
            GenerateNestedObjectWriteForTopLevel(sb, prop, access, indentLevel: 1);
            return;
        }

        sb.AppendLine("            writer.WriteIndent(1);");

        if (prop.IsNullable && prop.Category != PropertyCategory.String)
        {
            sb.AppendLine($"            if ({access} is null)");
            sb.AppendLine($"                writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine("            else");
            sb.Append("                ");
            GenerateSimplePropertyWriteCall(sb, prop, prop.IsNullable ? $"{access}.Value" : access);
        }
        else if (prop.Category == PropertyCategory.String && prop.IsNullable)
        {
            sb.AppendLine($"            if ({access} is null)");
            sb.AppendLine($"                writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine("            else");
            sb.Append("                ");
            GenerateSimplePropertyWriteCall(sb, prop, access);
        }
        else
        {
            sb.Append("            ");
            GenerateSimplePropertyWriteCall(sb, prop, access);
        }

        sb.AppendLine("            writer.WriteNewLine();");
    }

    private static void GenerateWritePropertiesMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Writes properties of <see cref=\"{typeInfo.FullyQualifiedName}\"/> to the writer (for nested object serialization).");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static void WriteProperties(ref TonlWriter writer, {typeInfo.FullyQualifiedName} value)");
        sb.AppendLine("        {");

        if (!typeInfo.IsValueType)
        {
            sb.AppendLine("            if (value is null) return;");
        }

        foreach (var prop in typeInfo.Properties)
        {
            GeneratePropertyWriteForNested(sb, prop, "value");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateWriteRowMethod(StringBuilder sb, SerializableTypeInfo typeInfo)
    {
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Writes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> as a tabular row (for array serialization).");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static void WriteRow(ref TonlWriter writer, {typeInfo.FullyQualifiedName} value)");
        sb.AppendLine("        {");

        if (!typeInfo.IsValueType)
        {
            sb.AppendLine("            if (value is null) return;");
        }

        sb.AppendLine("            writer.WriteIndent(2);");

        // Write all properties as comma-separated values
        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var access = $"value.{prop.Name}";

            if (i > 0)
            {
                sb.AppendLine("            writer.WriteDelimiter();");
            }

            GenerateRowValueWriteWithNullCheck(sb, prop, access);
        }

        sb.AppendLine("            writer.WriteNewLine();");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate WriteRowInline - same as WriteRow but without indent and newline (for inline object format)
        sb.AppendLine("        /// <summary>");
        sb.AppendLine($"        /// Writes a <see cref=\"{typeInfo.FullyQualifiedName}\"/> as inline values (no indent/newline).");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"        public static void WriteRowInline(ref TonlWriter writer, {typeInfo.FullyQualifiedName} value)");
        sb.AppendLine("        {");

        if (!typeInfo.IsValueType)
        {
            sb.AppendLine("            if (value is null) return;");
        }

        // Write all properties as comma-separated values (no indent, no final newline)
        for (int i = 0; i < typeInfo.Properties.Length; i++)
        {
            var prop = typeInfo.Properties[i];
            var access = $"value.{prop.Name}";

            if (i > 0)
            {
                sb.AppendLine("            writer.WriteDelimiter();");
            }

            GenerateRowValueWriteWithNullCheck(sb, prop, access);
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateRowValueWriteWithNullCheck(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For nullable value types, add null check and write "null" string for null values
        if (prop.IsNullable && prop.Category != PropertyCategory.String)
        {
            sb.AppendLine($"            if ({access} is null)");
            sb.AppendLine("                writer.WriteStringValue(\"null\");");
            sb.AppendLine("            else");
            sb.Append("    "); // Extra indent for else branch
            GenerateRowValueWrite(sb, prop, access);
        }
        else
        {
            GenerateRowValueWrite(sb, prop, access);
        }
    }

    private static void GeneratePropertyWriteForNested(StringBuilder sb, PropertyInfo prop, string valuePrefix)
    {
        var access = $"{valuePrefix}.{prop.Name}";

        // Handle collection and object properties specially - they need multi-line code blocks
        if (prop.Category == PropertyCategory.Collection)
        {
            GenerateCollectionWriteForTopLevel(sb, prop, access, indentLevel: 2);
            return;
        }
        if (prop.Category == PropertyCategory.Object)
        {
            GenerateNestedObjectWriteForTopLevel(sb, prop, access, indentLevel: 2);
            return;
        }

        sb.AppendLine("            writer.WriteIndent(2);");

        if (prop.IsNullable && prop.Category != PropertyCategory.String)
        {
            sb.AppendLine($"            if ({access} is null)");
            sb.AppendLine($"                writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine("            else");
            sb.Append("                ");
            GenerateSimplePropertyWriteCall(sb, prop, prop.IsNullable ? $"{access}.Value" : access);
        }
        else if (prop.Category == PropertyCategory.String && prop.IsNullable)
        {
            sb.AppendLine($"            if ({access} is null)");
            sb.AppendLine($"                writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine("            else");
            sb.Append("                ");
            GenerateSimplePropertyWriteCall(sb, prop, access);
        }
        else
        {
            sb.Append("            ");
            GenerateSimplePropertyWriteCall(sb, prop, access);
        }

        sb.AppendLine("            writer.WriteNewLine();");
    }

    private static void GenerateSimplePropertyWriteCall(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For nested serialization, only handle primitives - complex types fall back to ToString
        switch (prop.Category)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"writer.WriteKeyBoolean(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.Integer:
                if (prop.TypeName.Contains("UInt64") || prop.TypeName.Contains("ulong"))
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                else if (prop.TypeName.Contains("Int64") || prop.TypeName.Contains("long"))
                    sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", {access});");
                else if (prop.TypeName.Contains("UInt32") || prop.TypeName.Contains("uint"))
                    sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", {access});");
                else
                    sb.AppendLine($"writer.WriteKeyInt32(\"{prop.Name}\", (int){access});");
                break;
            case PropertyCategory.Float:
                if (prop.TypeName.Contains("Single") || prop.TypeName.Contains("float"))
                    sb.AppendLine($"writer.WriteKeyFloat(\"{prop.Name}\", {access});");
                else
                    sb.AppendLine($"writer.WriteKeyDouble(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"writer.WriteKeyDecimal(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.String:
                if (prop.TypeName.Contains("Char") || prop.TypeName == "char")
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                else
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", Convert.ToInt64({access}));");
                break;
            default:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}?.ToString() ?? \"\");");
                break;
        }
    }

    /// <summary>
    /// Generates collection write code for SerializeToString and WriteProperties methods.
    /// </summary>
    private static void GenerateCollectionWriteForTopLevel(StringBuilder sb, PropertyInfo prop, string access, int indentLevel)
    {
        var codeIndent = "            "; // 12 spaces for method body

        if (prop.IsDictionary)
        {
            // Dictionary serialization
            sb.AppendLine($"{codeIndent}if ({access} is not null)");
            sb.AppendLine($"{codeIndent}{{");
            sb.AppendLine($"{codeIndent}    writer.WriteIndent({indentLevel});");
            sb.AppendLine($"{codeIndent}    var dictKeys = {access}.Keys.Select(k => k?.ToString() ?? \"\").ToArray();");
            sb.AppendLine($"{codeIndent}    writer.WriteObjectHeader(\"{prop.Name}\", dictKeys);");
            sb.AppendLine($"{codeIndent}    writer.WriteNewLine();");
            sb.AppendLine($"{codeIndent}    foreach (var kvp in {access})");
            sb.AppendLine($"{codeIndent}    {{");
            sb.AppendLine($"{codeIndent}        writer.WriteIndent({indentLevel + 1});");

            // Write value based on element category
            if (prop.ElementCategory == PropertyCategory.Object && prop.ElementSafePropertyName != null && prop.ElementGeneratedNamespace != null)
            {
                sb.AppendLine($"{codeIndent}        if (kvp.Value is not null)");
                sb.AppendLine($"{codeIndent}        {{");
                sb.AppendLine($"{codeIndent}            writer.WriteObjectHeader(kvp.Key?.ToString() ?? \"\", {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.PropertyNames);");
                sb.AppendLine($"{codeIndent}            writer.WriteByte((byte)' ');");
                sb.AppendLine($"{codeIndent}            {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.WriteRowInline(ref writer, kvp.Value);");
                sb.AppendLine($"{codeIndent}        }}");
                sb.AppendLine($"{codeIndent}        else");
                sb.AppendLine($"{codeIndent}        {{");
                sb.AppendLine($"{codeIndent}            writer.WriteKeyNull(kvp.Key?.ToString() ?? \"\");");
                sb.AppendLine($"{codeIndent}        }}");
            }
            else
            {
                GenerateDictionaryValueWriteForTopLevel(sb, prop.ElementCategory, prop.ElementTypeName, codeIndent);
            }

            sb.AppendLine($"{codeIndent}        writer.WriteNewLine();");
            sb.AppendLine($"{codeIndent}    }}");
            sb.AppendLine($"{codeIndent}}}");
            sb.AppendLine($"{codeIndent}else");
            sb.AppendLine($"{codeIndent}{{");
            sb.AppendLine($"{codeIndent}    writer.WriteIndent({indentLevel});");
            sb.AppendLine($"{codeIndent}    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{codeIndent}    writer.WriteNewLine();");
            sb.AppendLine($"{codeIndent}}}");
        }
        else
        {
            // Array/List serialization
            sb.AppendLine($"{codeIndent}if ({access} is not null)");
            sb.AppendLine($"{codeIndent}{{");
            sb.AppendLine($"{codeIndent}    var items = {access}.ToList();");
            sb.AppendLine($"{codeIndent}    writer.WriteIndent({indentLevel});");

            if (prop.ElementCategory == PropertyCategory.Object && prop.ElementSafePropertyName != null && prop.ElementGeneratedNamespace != null)
            {
                // Collection of objects - tabular format
                sb.AppendLine($"{codeIndent}    writer.WriteArrayHeader(\"{prop.Name}\", items.Count, {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.PropertyNames);");
                sb.AppendLine($"{codeIndent}    writer.WriteNewLine();");
                sb.AppendLine($"{codeIndent}    foreach (var item in items)");
                sb.AppendLine($"{codeIndent}    {{");
                sb.AppendLine($"{codeIndent}        if (item is not null)");
                sb.AppendLine($"{codeIndent}        {{");
                sb.AppendLine($"{codeIndent}            writer.WriteIndent({indentLevel + 1});");
                sb.AppendLine($"{codeIndent}            {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.WriteRowInline(ref writer, item);");
                sb.AppendLine($"{codeIndent}            writer.WriteNewLine();");
                sb.AppendLine($"{codeIndent}        }}");
                sb.AppendLine($"{codeIndent}    }}");
            }
            else
            {
                // Collection of primitives - inline format
                sb.AppendLine($"{codeIndent}    writer.WriteKey(\"{prop.Name}\");");
                sb.AppendLine($"{codeIndent}    writer.WriteByte((byte)'[');");
                sb.AppendLine($"{codeIndent}    writer.WriteInt32(items.Count);");
                sb.AppendLine($"{codeIndent}    writer.WriteByte((byte)']');");
                sb.AppendLine($"{codeIndent}    writer.WriteByte((byte)':');");
                sb.AppendLine($"{codeIndent}    writer.WriteByte((byte)' ');");
                sb.AppendLine($"{codeIndent}    for (int i = 0; i < items.Count; i++)");
                sb.AppendLine($"{codeIndent}    {{");
                sb.AppendLine($"{codeIndent}        if (i > 0)");
                sb.AppendLine($"{codeIndent}        {{");
                sb.AppendLine($"{codeIndent}            writer.WriteDelimiter();");
                sb.AppendLine($"{codeIndent}        }}");
                GenerateArrayElementWriteForTopLevel(sb, prop.ElementCategory, prop.ElementTypeName, codeIndent);
                sb.AppendLine($"{codeIndent}    }}");
                sb.AppendLine($"{codeIndent}    writer.WriteNewLine();");
            }

            sb.AppendLine($"{codeIndent}}}");
            sb.AppendLine($"{codeIndent}else");
            sb.AppendLine($"{codeIndent}{{");
            sb.AppendLine($"{codeIndent}    writer.WriteIndent({indentLevel});");
            sb.AppendLine($"{codeIndent}    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{codeIndent}    writer.WriteNewLine();");
            sb.AppendLine($"{codeIndent}}}");
        }
    }

    private static void GenerateDictionaryValueWriteForTopLevel(StringBuilder sb, PropertyCategory elementCategory, string? elementTypeName, string codeIndent)
    {
        switch (elementCategory)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyBoolean(kvp.Key?.ToString() ?? \"\", kvp.Value);");
                break;
            case PropertyCategory.Integer:
                if (elementTypeName?.Contains("Int64") == true || elementTypeName?.Contains("long") == true)
                    sb.AppendLine($"{codeIndent}        writer.WriteKeyInt64(kvp.Key?.ToString() ?? \"\", kvp.Value);");
                else
                    sb.AppendLine($"{codeIndent}        writer.WriteKeyInt32(kvp.Key?.ToString() ?? \"\", (int)kvp.Value);");
                break;
            case PropertyCategory.Float:
                if (elementTypeName?.Contains("Single") == true || elementTypeName?.Contains("float") == true)
                    sb.AppendLine($"{codeIndent}        writer.WriteKeyFloat(kvp.Key?.ToString() ?? \"\", kvp.Value);");
                else
                    sb.AppendLine($"{codeIndent}        writer.WriteKeyDouble(kvp.Key?.ToString() ?? \"\", kvp.Value);");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyDecimal(kvp.Key?.ToString() ?? \"\", kvp.Value);");
                break;
            case PropertyCategory.String:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", kvp.Value ?? \"\");");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", kvp.Value.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", kvp.Value.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyInt64(kvp.Key?.ToString() ?? \"\", Convert.ToInt64(kvp.Value));");
                break;
            default:
                sb.AppendLine($"{codeIndent}        writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", kvp.Value?.ToString() ?? \"\");");
                break;
        }
    }

    private static void GenerateArrayElementWriteForTopLevel(StringBuilder sb, PropertyCategory elementCategory, string? elementTypeName, string codeIndent)
    {
        switch (elementCategory)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"{codeIndent}        writer.WriteBoolean(items[i]);");
                break;
            case PropertyCategory.Integer:
                if (elementTypeName?.Contains("Int64") == true || elementTypeName?.Contains("long") == true)
                    sb.AppendLine($"{codeIndent}        writer.WriteInt64(items[i]);");
                else
                    sb.AppendLine($"{codeIndent}        writer.WriteInt32((int)items[i]);");
                break;
            case PropertyCategory.Float:
                if (elementTypeName?.Contains("Single") == true || elementTypeName?.Contains("float") == true)
                    sb.AppendLine($"{codeIndent}        writer.WriteFloat(items[i]);");
                else
                    sb.AppendLine($"{codeIndent}        writer.WriteDouble(items[i]);");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"{codeIndent}        writer.WriteDecimal(items[i]);");
                break;
            case PropertyCategory.String:
                sb.AppendLine($"{codeIndent}        writer.WriteStringValue(items[i] ?? \"\");");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"{codeIndent}        writer.WriteStringValue(items[i].ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"{codeIndent}        writer.WriteStringValue(items[i].ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"{codeIndent}        writer.WriteInt64(Convert.ToInt64(items[i]));");
                break;
            default:
                sb.AppendLine($"{codeIndent}        writer.WriteStringValue(items[i]?.ToString() ?? \"\");");
                break;
        }
    }

    /// <summary>
    /// Generates nested object write code for SerializeToString and WriteProperties methods.
    /// </summary>
    private static void GenerateNestedObjectWriteForTopLevel(StringBuilder sb, PropertyInfo prop, string access, int indentLevel)
    {
        var codeIndent = "            "; // 12 spaces for method body

        sb.AppendLine($"{codeIndent}writer.WriteIndent({indentLevel});");

        if (prop.ObjectSafePropertyName != null && prop.ObjectGeneratedNamespace != null)
        {
            sb.AppendLine($"{codeIndent}if ({access} is not null)");
            sb.AppendLine($"{codeIndent}{{");
            sb.AppendLine($"{codeIndent}    writer.WriteObjectHeader(\"{prop.Name}\", {prop.ObjectGeneratedNamespace}.{prop.ObjectSafePropertyName}TonlSerializer.PropertyNames);");
            sb.AppendLine($"{codeIndent}    writer.WriteByte((byte)' ');");
            sb.AppendLine($"{codeIndent}    {prop.ObjectGeneratedNamespace}.{prop.ObjectSafePropertyName}TonlSerializer.WriteRowInline(ref writer, {access});");
            sb.AppendLine($"{codeIndent}}}");
            sb.AppendLine($"{codeIndent}else");
            sb.AppendLine($"{codeIndent}{{");
            sb.AppendLine($"{codeIndent}    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{codeIndent}}}");
        }
        else
        {
            // Unknown object type - fall back to ToString
            sb.AppendLine($"{codeIndent}writer.WriteKeyValue(\"{prop.Name}\", {access}?.ToString() ?? \"\");");
        }

        sb.AppendLine($"{codeIndent}writer.WriteNewLine();");
    }

    private static void GenerateRowValueWrite(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For nullable value types (not string), use .Value to extract the underlying value
        // The null check should be handled by the caller
        var valueAccess = (prop.IsNullable && prop.Category != PropertyCategory.String)
            ? $"{access}.Value"
            : access;

        // Write value without key for tabular format
        switch (prop.Category)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"            writer.WriteBoolean({valueAccess});");
                break;
            case PropertyCategory.Integer:
                if (prop.TypeName.Contains("UInt64") || prop.TypeName.Contains("ulong"))
                    sb.AppendLine($"            writer.WriteStringValue({valueAccess}.ToString());");
                else if (prop.TypeName.Contains("Int64") || prop.TypeName.Contains("long"))
                    sb.AppendLine($"            writer.WriteInt64({valueAccess});");
                else if (prop.TypeName.Contains("UInt32") || prop.TypeName.Contains("uint"))
                    sb.AppendLine($"            writer.WriteInt64({valueAccess});");
                else
                    sb.AppendLine($"            writer.WriteInt32((int){valueAccess});");
                break;
            case PropertyCategory.Float:
                if (prop.TypeName.Contains("Single") || prop.TypeName.Contains("float"))
                    sb.AppendLine($"            writer.WriteFloat({valueAccess});");
                else
                    sb.AppendLine($"            writer.WriteDouble({valueAccess});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"            writer.WriteDecimal({valueAccess});");
                break;
            case PropertyCategory.String:
                if (prop.TypeName.Contains("Char") || prop.TypeName == "char")
                    sb.AppendLine($"            writer.WriteStringValue({access}.ToString());");
                else if (prop.IsNullable)
                    sb.AppendLine($"            writer.WriteStringValue({access} ?? \"\");");
                else
                    sb.AppendLine($"            writer.WriteStringValue({access});");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"            writer.WriteStringValue({valueAccess}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"            writer.WriteStringValue({valueAccess}.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"            writer.WriteInt64(Convert.ToInt64({valueAccess}));");
                break;
            case PropertyCategory.Collection:
                GenerateRowValueWriteForCollection(sb, prop, access);
                break;
            case PropertyCategory.Object:
                GenerateRowValueWriteForObject(sb, prop, access);
                break;
            default:
                sb.AppendLine($"            writer.WriteStringValue({access}?.ToString() ?? \"\");");
                break;
        }
    }

    /// <summary>
    /// Generates code to write a collection property value in tabular row format.
    /// Collections are serialized inline within the cell.
    /// </summary>
    private static void GenerateRowValueWriteForCollection(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For tabular rows, serialize collection inline
        // Primitives: join with semicolon delimiter
        // Objects: use WriteRowInline for each element

        sb.AppendLine($"            if ({access} is null || !{access}.Any())");
        sb.AppendLine($"                writer.WriteStringValue(\"\");");
        sb.AppendLine($"            else");
        sb.AppendLine($"            {{");

        if (prop.IsDictionary)
        {
            // Dictionary - serialize as key=value pairs
            if (prop.ElementCategory == PropertyCategory.Object && prop.ElementSafePropertyName != null && prop.ElementGeneratedNamespace != null)
            {
                // Dictionary with object values - use WriteRowInline for each value
                sb.AppendLine($"                var isFirst = true;");
                sb.AppendLine($"                foreach (var kvp in {access})");
                sb.AppendLine($"                {{");
                sb.AppendLine($"                    if (!isFirst) writer.WriteByte((byte)';');");
                sb.AppendLine($"                    isFirst = false;");
                sb.AppendLine($"                    writer.WriteStringValue(kvp.Key?.ToString() ?? \"\");");
                sb.AppendLine($"                    writer.WriteByte((byte)'=');");
                sb.AppendLine($"                    {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.WriteRowInline(ref writer, kvp.Value);");
                sb.AppendLine($"                }}");
            }
            else
            {
                // Dictionary with primitive values - serialize as key=value pairs
                sb.AppendLine($"                var joined = string.Join(\";\", {access}.Select(kvp => $\"{{kvp.Key}}={{kvp.Value}}\"));");
                sb.AppendLine($"                writer.WriteStringValue(joined);");
            }
        }
        else if (prop.ElementCategory == PropertyCategory.Object && prop.ElementSafePropertyName != null && prop.ElementGeneratedNamespace != null)
        {
            // List/Array of objects - use WriteRowInline for each element with inner delimiter
            sb.AppendLine($"                var isFirst = true;");
            sb.AppendLine($"                foreach (var item in {access})");
            sb.AppendLine($"                {{");
            sb.AppendLine($"                    if (!isFirst) writer.WriteByte((byte)';');");
            sb.AppendLine($"                    isFirst = false;");
            sb.AppendLine($"                    {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.WriteRowInline(ref writer, item);");
            sb.AppendLine($"                }}");
        }
        else
        {
            // List/Array of primitives - join with semicolon
            sb.AppendLine($"                var joined = string.Join(\";\", {access});");
            sb.AppendLine($"                writer.WriteStringValue(joined);");
        }

        sb.AppendLine($"            }}");
    }

    /// <summary>
    /// Generates code to write an object property value in tabular row format.
    /// Objects are serialized inline using WriteRowInline.
    /// </summary>
    private static void GenerateRowValueWriteForObject(StringBuilder sb, PropertyInfo prop, string access)
    {
        if (prop.ObjectSafePropertyName != null && prop.ObjectGeneratedNamespace != null)
        {
            // Use WriteRowInline for the nested object
            sb.AppendLine($"            if ({access} is null)");
            sb.AppendLine($"                writer.WriteStringValue(\"\");");
            sb.AppendLine($"            else");
            sb.AppendLine($"                {prop.ObjectGeneratedNamespace}.{prop.ObjectSafePropertyName}TonlSerializer.WriteRowInline(ref writer, {access});");
        }
        else
        {
            // Fallback to ToString if no serializer available
            sb.AppendLine($"            writer.WriteStringValue({access}?.ToString() ?? \"\");");
        }
    }

    /// <summary>
    /// Generates a TonlSerializerContext partial class with type info properties.
    /// </summary>
    public static string GenerateContext(ContextInfo contextInfo)
    {
        var sb = new StringBuilder(8192);

        // Filter out primitive types - they should be handled by core serialization
        var types = contextInfo.Types.Where(t => !t.IsPrimitive).ToList();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Buffers;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using TONL.NET;");
        sb.AppendLine();

        if (contextInfo.Namespace != null)
        {
            sb.AppendLine($"namespace {contextInfo.Namespace}");
            sb.AppendLine("{");
        }

        var indent = contextInfo.Namespace != null ? "    " : "";

        sb.AppendLine($"{indent}public partial class {contextInfo.ContextName}");
        sb.AppendLine($"{indent}{{");

        // Default singleton
        sb.AppendLine($"{indent}    private static {contextInfo.ContextName}? _default;");
        sb.AppendLine($"{indent}    public static {contextInfo.ContextName} Default => _default ??= new {contextInfo.ContextName}();");
        sb.AppendLine();

        // Type info backing fields and properties (exclude primitives)
        foreach (var type in types)
        {
            sb.AppendLine($"{indent}    private TonlTypeInfo<{type.FullyQualifiedName}>? _{type.SafePropertyName};");
            sb.AppendLine($"{indent}    public TonlTypeInfo<{type.FullyQualifiedName}> {type.SafePropertyName} => _{type.SafePropertyName} ??= Create{type.SafePropertyName}TypeInfo();");
            sb.AppendLine();
        }

        // GetTypeInfo override
        sb.AppendLine($"{indent}    public override TonlTypeInfo? GetTypeInfo(Type type)");
        sb.AppendLine($"{indent}    {{");
        foreach (var type in types)
        {
            sb.AppendLine($"{indent}        if (type == typeof({type.FullyQualifiedName})) return {type.SafePropertyName};");
        }
        sb.AppendLine($"{indent}        return null;");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // CreateXxxTypeInfo methods
        foreach (var type in types)
        {
            GenerateCreateTypeInfoMethod(sb, type, contextInfo.GenerationMode, indent);
        }

        sb.AppendLine($"{indent}}}");

        if (contextInfo.Namespace != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void GenerateCreateTypeInfoMethod(
        StringBuilder sb,
        SerializableTypeInfo type,
        TonlSourceGenerationMode mode,
        string indent)
    {
        sb.AppendLine($"{indent}    private TonlTypeInfo<{type.FullyQualifiedName}> Create{type.SafePropertyName}TypeInfo()");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        return new TonlTypeInfo<{type.FullyQualifiedName}>");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            OriginatingContext = this,");

        // Add collection metadata for collection types
        if (type.IsCollection)
        {
            sb.AppendLine($"{indent}            IsCollection = true,");
            if (type.IsDictionaryCollection)
            {
                sb.AppendLine($"{indent}            IsDictionary = true,");
            }
            // For collections of objects, include element property names for tabular headers
            if (type.CollectionElementCategory == PropertyCategory.Object &&
                type.CollectionElementSafePropertyName != null &&
                type.CollectionElementGeneratedNamespace != null)
            {
                sb.AppendLine($"{indent}            CollectionElementPropertyNames = {type.CollectionElementGeneratedNamespace}.{type.CollectionElementSafePropertyName}TonlSerializer.PropertyNames,");
            }
        }

        // Generate fast-path serialize handler
        if (mode == TonlSourceGenerationMode.Default || mode == TonlSourceGenerationMode.Serialization)
        {
            GenerateFastPathSerializer(sb, type, indent);
        }

        // Generate metadata for deserialization
        if (mode == TonlSourceGenerationMode.Default || mode == TonlSourceGenerationMode.Metadata)
        {
            GenerateMetadata(sb, type, indent);
        }

        sb.AppendLine($"{indent}        }};");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();
    }

    private static void GenerateFastPathSerializer(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        // Non-static lambda captures 'this' (the context) to enable delegation to nested type serializers
        sb.AppendLine($"{indent}            Serialize = (ref TonlWriter writer, {type.FullyQualifiedName} value) =>");
        sb.AppendLine($"{indent}            {{");

        if (!type.IsValueType)
        {
            sb.AppendLine($"{indent}                if (value is null) return;");
        }

        // Handle collection types registered as root types
        if (type.IsCollection)
        {
            GenerateRootCollectionWrite(sb, type, indent);
        }
        else
        {
            // Standard object property serialization
            foreach (var prop in type.Properties)
            {
                GeneratePropertyWrite(sb, prop, indent);
            }
        }

        sb.AppendLine($"{indent}            }},");
    }

    /// <summary>
    /// Generates serialization code for collection types registered as root types.
    /// </summary>
    private static void GenerateRootCollectionWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        if (type.IsDictionaryCollection)
        {
            GenerateRootDictionaryWrite(sb, type, indent);
        }
        else
        {
            // List<T>, Array, IEnumerable<T>
            GenerateRootListWrite(sb, type, indent);
        }
    }

    /// <summary>
    /// Generates serialization code for root-level dictionary types.
    /// </summary>
    private static void GenerateRootDictionaryWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        // Dictionary: write each key-value pair
        sb.AppendLine($"{indent}                foreach (var kvp in value)");
        sb.AppendLine($"{indent}                {{");
        sb.AppendLine($"{indent}                    writer.WriteIndent(1);");

        // Write the key-value based on element category
        GenerateRootDictionaryKvpWrite(sb, type, indent);

        sb.AppendLine($"{indent}                    writer.WriteNewLine();");
        sb.AppendLine($"{indent}                }}");
    }

    /// <summary>
    /// Generates the write call for a single key-value pair in a root dictionary.
    /// </summary>
    private static void GenerateRootDictionaryKvpWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        var valueAccess = "kvp.Value";
        var keyAccess = "kvp.Key?.ToString() ?? \"\"";

        switch (type.CollectionElementCategory)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"{indent}                    writer.WriteKeyBoolean({keyAccess}, {valueAccess});");
                break;
            case PropertyCategory.Integer:
                if (type.CollectionElementTypeName?.Contains("Int64") == true || type.CollectionElementTypeName?.Contains("long") == true)
                    sb.AppendLine($"{indent}                    writer.WriteKeyInt64({keyAccess}, {valueAccess});");
                else
                    sb.AppendLine($"{indent}                    writer.WriteKeyInt32({keyAccess}, (int){valueAccess});");
                break;
            case PropertyCategory.Float:
                if (type.CollectionElementTypeName?.Contains("Single") == true || type.CollectionElementTypeName?.Contains("float") == true)
                    sb.AppendLine($"{indent}                    writer.WriteKeyFloat({keyAccess}, {valueAccess});");
                else
                    sb.AppendLine($"{indent}                    writer.WriteKeyDouble({keyAccess}, {valueAccess});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"{indent}                    writer.WriteKeyDecimal({keyAccess}, {valueAccess});");
                break;
            case PropertyCategory.String:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {valueAccess} ?? \"\");");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {valueAccess}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {valueAccess}.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"{indent}                    writer.WriteKeyInt64({keyAccess}, Convert.ToInt64({valueAccess}));");
                break;
            case PropertyCategory.Object:
                // Complex object values in dictionary - use inline format if we have element type info
                if (type.CollectionElementSafePropertyName != null && type.CollectionElementGeneratedNamespace != null)
                {
                    sb.AppendLine($"{indent}                    if ({valueAccess} is not null)");
                    sb.AppendLine($"{indent}                    {{");
                    sb.AppendLine($"{indent}                        writer.WriteObjectHeader({keyAccess}, {type.CollectionElementGeneratedNamespace}.{type.CollectionElementSafePropertyName}TonlSerializer.PropertyNames);");
                    sb.AppendLine($"{indent}                        writer.WriteByte((byte)' ');");
                    sb.AppendLine($"{indent}                        {type.CollectionElementGeneratedNamespace}.{type.CollectionElementSafePropertyName}TonlSerializer.WriteRowInline(ref writer, {valueAccess});");
                    sb.AppendLine($"{indent}                    }}");
                    sb.AppendLine($"{indent}                    else");
                    sb.AppendLine($"{indent}                    {{");
                    sb.AppendLine($"{indent}                        writer.WriteKeyNull({keyAccess});");
                    sb.AppendLine($"{indent}                    }}");
                }
                else
                {
                    sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {valueAccess}?.ToString() ?? \"\");");
                }
                break;
            default:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {valueAccess}?.ToString() ?? \"\");");
                break;
        }
    }

    /// <summary>
    /// Generates serialization code for root-level list/array types.
    /// </summary>
    private static void GenerateRootListWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        if (type.CollectionElementCategory == PropertyCategory.Object &&
            type.CollectionElementSafePropertyName != null &&
            type.CollectionElementGeneratedNamespace != null)
        {
            // Complex objects - use tabular format
            GenerateRootListOfObjectsWrite(sb, type, indent);
        }
        else
        {
            // Primitives - inline format
            GenerateRootListOfPrimitivesWrite(sb, type, indent);
        }
    }

    /// <summary>
    /// Generates serialization code for root-level list of complex objects (tabular format).
    /// </summary>
    private static void GenerateRootListOfObjectsWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        // Tabular format: write each item as a row
        sb.AppendLine($"{indent}                foreach (var item in value)");
        sb.AppendLine($"{indent}                {{");
        sb.AppendLine($"{indent}                    if (item is not null)");
        sb.AppendLine($"{indent}                    {{");
        sb.AppendLine($"{indent}                        {type.CollectionElementGeneratedNamespace}.{type.CollectionElementSafePropertyName}TonlSerializer.WriteRow(ref writer, item);");
        sb.AppendLine($"{indent}                    }}");
        sb.AppendLine($"{indent}                }}");
    }

    /// <summary>
    /// Generates serialization code for root-level list of primitives.
    /// </summary>
    private static void GenerateRootListOfPrimitivesWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        // Write each primitive as a simple key: value line
        sb.AppendLine($"{indent}                int index = 0;");
        sb.AppendLine($"{indent}                foreach (var item in value)");
        sb.AppendLine($"{indent}                {{");
        sb.AppendLine($"{indent}                    writer.WriteIndent(1);");

        GenerateRootPrimitiveItemWrite(sb, type, indent);

        sb.AppendLine($"{indent}                    writer.WriteNewLine();");
        sb.AppendLine($"{indent}                    index++;");
        sb.AppendLine($"{indent}                }}");
    }

    /// <summary>
    /// Generates the write call for a single primitive item in a root collection.
    /// </summary>
    private static void GenerateRootPrimitiveItemWrite(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        var itemAccess = "item";
        var keyAccess = "index.ToString()";

        switch (type.CollectionElementCategory)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"{indent}                    writer.WriteKeyBoolean({keyAccess}, {itemAccess});");
                break;
            case PropertyCategory.Integer:
                if (type.CollectionElementTypeName?.Contains("Int64") == true || type.CollectionElementTypeName?.Contains("long") == true)
                    sb.AppendLine($"{indent}                    writer.WriteKeyInt64({keyAccess}, {itemAccess});");
                else
                    sb.AppendLine($"{indent}                    writer.WriteKeyInt32({keyAccess}, (int){itemAccess});");
                break;
            case PropertyCategory.Float:
                if (type.CollectionElementTypeName?.Contains("Single") == true || type.CollectionElementTypeName?.Contains("float") == true)
                    sb.AppendLine($"{indent}                    writer.WriteKeyFloat({keyAccess}, {itemAccess});");
                else
                    sb.AppendLine($"{indent}                    writer.WriteKeyDouble({keyAccess}, {itemAccess});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"{indent}                    writer.WriteKeyDecimal({keyAccess}, {itemAccess});");
                break;
            case PropertyCategory.String:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {itemAccess} ?? \"\");");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {itemAccess}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {itemAccess}.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"{indent}                    writer.WriteKeyInt64({keyAccess}, Convert.ToInt64({itemAccess}));");
                break;
            default:
                sb.AppendLine($"{indent}                    writer.WriteKeyValue({keyAccess}, {itemAccess}?.ToString() ?? \"\");");
                break;
        }
    }

    private static void GeneratePropertyWrite(StringBuilder sb, PropertyInfo prop, string indent)
    {
        var access = $"value.{prop.Name}";

        sb.AppendLine($"{indent}                writer.WriteIndent(1);");

        if (prop.IsNullable && prop.Category != PropertyCategory.String)
        {
            sb.AppendLine($"{indent}                if ({access} is null)");
            sb.AppendLine($"{indent}                    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{indent}                else");
            sb.Append($"{indent}                    ");
            GeneratePropertyWriteCall(sb, prop, $"{access}.Value");
        }
        else if (prop.Category == PropertyCategory.String && prop.IsNullable)
        {
            sb.AppendLine($"{indent}                if ({access} is null)");
            sb.AppendLine($"{indent}                    writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine($"{indent}                else");
            sb.Append($"{indent}                    ");
            GeneratePropertyWriteCall(sb, prop, access);
        }
        else
        {
            sb.Append($"{indent}                ");
            GeneratePropertyWriteCall(sb, prop, access);
        }

        sb.AppendLine($"{indent}                writer.WriteNewLine();");
    }

    private static void GeneratePropertyWriteCall(StringBuilder sb, PropertyInfo prop, string access)
    {
        switch (prop.Category)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"writer.WriteKeyBoolean(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.Integer:
                // Handle all integer types appropriately
                if (prop.TypeName.Contains("UInt64") || prop.TypeName.Contains("ulong"))
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());"); // ulong as string to preserve full range
                else if (prop.TypeName.Contains("Int64") || prop.TypeName.Contains("long"))
                    sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", {access});");
                else if (prop.TypeName.Contains("UInt32") || prop.TypeName.Contains("uint"))
                    sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", {access});"); // uint fits in long
                else
                    sb.AppendLine($"writer.WriteKeyInt32(\"{prop.Name}\", (int){access});");
                break;
            case PropertyCategory.Float:
                // Use proper float/double/decimal methods to preserve precision
                if (prop.TypeName.Contains("Single") || prop.TypeName.Contains("float"))
                    sb.AppendLine($"writer.WriteKeyFloat(\"{prop.Name}\", {access});");
                else
                    sb.AppendLine($"writer.WriteKeyDouble(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"writer.WriteKeyDecimal(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.String:
                // Handle char vs string
                if (prop.TypeName.Contains("Char") || prop.TypeName == "char")
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                else
                    sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access});");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}.ToString());");
                break;
            case PropertyCategory.Enum:
                // Use Int64 to safely handle all enum underlying types (byte, sbyte, short, ushort, int, uint, long)
                // Note: ulong-backed enums with values > long.MaxValue are not supported
                sb.AppendLine($"writer.WriteKeyInt64(\"{prop.Name}\", Convert.ToInt64({access}));");
                break;
            case PropertyCategory.Collection:
                GenerateCollectionWrite(sb, prop, access);
                break;
            case PropertyCategory.Object:
                GenerateNestedObjectWrite(sb, prop, access);
                break;
            default:
                sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}?.ToString() ?? \"\");");
                break;
        }
    }

    private static void GenerateCollectionWrite(StringBuilder sb, PropertyInfo prop, string access)
    {
        if (prop.IsDictionary)
        {
            // Dictionary<K,V> - serialize as nested object with key-value pairs
            GenerateDictionaryWrite(sb, prop, access);
        }
        else
        {
            // Array, List<T>, IEnumerable<T>, etc. - serialize as array
            GenerateArrayWrite(sb, prop, access);
        }
    }

    private static void GenerateDictionaryWrite(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For dictionaries, we need to write each key-value pair
        // Format: key{subkey1,subkey2,...}:
        //   subkey1: value1
        //   subkey2: value2
        sb.AppendLine("{");
        sb.AppendLine($"                    if ({access} is not null)");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        var dictKeys = {access}.Keys.Select(k => k?.ToString() ?? \"\").ToArray();");
        sb.AppendLine($"                        writer.WriteObjectHeader(\"{prop.Name}\", dictKeys);");
        sb.AppendLine("                        writer.WriteNewLine();");
        sb.AppendLine($"                        foreach (var kvp in {access})");
        sb.AppendLine("                        {");
        sb.AppendLine("                            writer.WriteIndent(2);");

        // Write the value based on its category
        if (prop.ElementCategory == PropertyCategory.Object && prop.ElementSafePropertyName != null)
        {
            // Nested object in dictionary - delegate to context
            sb.AppendLine($"                            writer.WriteKey(kvp.Key?.ToString() ?? \"\");");
            sb.AppendLine("                            writer.WriteNewLine();");
            sb.AppendLine($"                            // TODO: Nested object serialization in dictionary requires context access");
        }
        else
        {
            // Primitive value
            GenerateDictionaryValueWrite(sb, prop.ElementCategory, prop.ElementTypeName);
        }

        sb.AppendLine("                            writer.WriteNewLine();");
        sb.AppendLine("                        }");
        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        writer.WriteKeyNull(\"{prop.Name}\");");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
    }

    private static void GenerateDictionaryValueWrite(StringBuilder sb, PropertyCategory elementCategory, string? elementTypeName)
    {
        var valueAccess = "kvp.Value";
        switch (elementCategory)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"                            writer.WriteKeyBoolean(kvp.Key?.ToString() ?? \"\", {valueAccess});");
                break;
            case PropertyCategory.Integer:
                if (elementTypeName?.Contains("Int64") == true || elementTypeName?.Contains("long") == true)
                    sb.AppendLine($"                            writer.WriteKeyInt64(kvp.Key?.ToString() ?? \"\", {valueAccess});");
                else
                    sb.AppendLine($"                            writer.WriteKeyInt32(kvp.Key?.ToString() ?? \"\", (int){valueAccess});");
                break;
            case PropertyCategory.Float:
                if (elementTypeName?.Contains("Single") == true || elementTypeName?.Contains("float") == true)
                    sb.AppendLine($"                            writer.WriteKeyFloat(kvp.Key?.ToString() ?? \"\", {valueAccess});");
                else
                    sb.AppendLine($"                            writer.WriteKeyDouble(kvp.Key?.ToString() ?? \"\", {valueAccess});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"                            writer.WriteKeyDecimal(kvp.Key?.ToString() ?? \"\", {valueAccess});");
                break;
            case PropertyCategory.String:
                sb.AppendLine($"                            writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", {valueAccess} ?? \"\");");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"                            writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", {valueAccess}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"                            writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", {valueAccess}.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"                            writer.WriteKeyInt64(kvp.Key?.ToString() ?? \"\", Convert.ToInt64({valueAccess}));");
                break;
            default:
                sb.AppendLine($"                            writer.WriteKeyValue(kvp.Key?.ToString() ?? \"\", {valueAccess}?.ToString() ?? \"\");");
                break;
        }
    }

    private static void GenerateArrayWrite(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For arrays/lists, serialize elements
        // Format for primitives: key[N]: val1, val2, val3
        // Format for objects (per TONL spec): key[N]{col1,col2}:
        //   val1, val2
        //   val3, val4

        sb.AppendLine("{");
        sb.AppendLine($"                    if ({access} is not null)");
        sb.AppendLine("                    {");

        if (prop.ElementCategory == PropertyCategory.Object && prop.ElementSafePropertyName != null && prop.ElementGeneratedNamespace != null)
        {
            // Collection of complex objects - use tabular format per TONL spec
            // Format: key[N]{col1,col2}:
            //           val1, val2
            //           val3, val4
            sb.AppendLine($"                        var items = {access}.ToList();");
            sb.AppendLine($"                        // Use element type's property names for column headers");
            sb.AppendLine($"                        writer.WriteArrayHeader(\"{prop.Name}\", items.Count, {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.PropertyNames);");
            sb.AppendLine("                        writer.WriteNewLine();");
            sb.AppendLine("                        foreach (var item in items)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            if (item is not null)");
            sb.AppendLine("                            {");
            sb.AppendLine($"                                // Use WriteRow for tabular format");
            sb.AppendLine($"                                {prop.ElementGeneratedNamespace}.{prop.ElementSafePropertyName}TonlSerializer.WriteRow(ref writer, item);");
            sb.AppendLine("                            }");
            sb.AppendLine("                        }");
        }
        else
        {
            // Collection of primitives - write as comma-separated values: key[N]: val1, val2, val3
            sb.AppendLine($"                        var items = {access}.ToList();");
            sb.AppendLine($"                        writer.WriteKey(\"{prop.Name}\");");
            sb.AppendLine("                        writer.WriteByte((byte)'[');");
            sb.AppendLine("                        writer.WriteInt32(items.Count);");
            sb.AppendLine("                        writer.WriteByte((byte)']');");
            sb.AppendLine("                        writer.WriteByte((byte)':');");
            sb.AppendLine("                        writer.WriteByte((byte)' ');");
            sb.AppendLine("                        for (int i = 0; i < items.Count; i++)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            if (i > 0)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                writer.WriteDelimiter();");
            sb.AppendLine("                            }");
            GenerateArrayElementWrite(sb, prop.ElementCategory, prop.ElementTypeName);
            sb.AppendLine("                        }");
        }

        sb.AppendLine("                    }");
        sb.AppendLine("                    else");
        sb.AppendLine("                    {");
        sb.AppendLine($"                        writer.WriteKeyNull(\"{prop.Name}\");");
        sb.AppendLine("                    }");
        sb.AppendLine("                }");
    }

    private static void GenerateArrayElementWrite(StringBuilder sb, PropertyCategory elementCategory, string? elementTypeName)
    {
        var itemAccess = "items[i]";
        switch (elementCategory)
        {
            case PropertyCategory.Boolean:
                sb.AppendLine($"                            writer.WriteBoolean({itemAccess});");
                break;
            case PropertyCategory.Integer:
                if (elementTypeName?.Contains("Int64") == true || elementTypeName?.Contains("long") == true)
                    sb.AppendLine($"                            writer.WriteInt64({itemAccess});");
                else
                    sb.AppendLine($"                            writer.WriteInt32((int){itemAccess});");
                break;
            case PropertyCategory.Float:
                if (elementTypeName?.Contains("Single") == true || elementTypeName?.Contains("float") == true)
                    sb.AppendLine($"                            writer.WriteFloat({itemAccess});");
                else
                    sb.AppendLine($"                            writer.WriteDouble({itemAccess});");
                break;
            case PropertyCategory.Decimal:
                sb.AppendLine($"                            writer.WriteDecimal({itemAccess});");
                break;
            case PropertyCategory.String:
                sb.AppendLine($"                            writer.WriteStringValue({itemAccess} ?? \"\");");
                break;
            case PropertyCategory.DateTime:
                sb.AppendLine($"                            writer.WriteStringValue({itemAccess}.ToString(\"O\"));");
                break;
            case PropertyCategory.Guid:
            case PropertyCategory.TimeSpan:
                sb.AppendLine($"                            writer.WriteStringValue({itemAccess}.ToString());");
                break;
            case PropertyCategory.Enum:
                sb.AppendLine($"                            writer.WriteInt64(Convert.ToInt64({itemAccess}));");
                break;
            default:
                sb.AppendLine($"                            writer.WriteStringValue({itemAccess}?.ToString() ?? \"\");");
                break;
        }
    }

    private static void GenerateNestedObjectWrite(StringBuilder sb, PropertyInfo prop, string access)
    {
        // For nested objects, use inline format per TONL spec: key{col1,col2}: val1, val2
        // Or if values don't fit inline, use block format with WriteRow
        if (prop.ObjectSafePropertyName != null && prop.ObjectGeneratedNamespace != null)
        {
            sb.AppendLine("{");
            sb.AppendLine($"                    if ({access} is not null)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        // Use inline object format per TONL spec: key{{col1,col2}}: val1, val2");
            sb.AppendLine($"                        writer.WriteObjectHeader(\"{prop.Name}\", {prop.ObjectGeneratedNamespace}.{prop.ObjectSafePropertyName}TonlSerializer.PropertyNames);");
            sb.AppendLine("                        writer.WriteByte((byte)' ');");
            sb.AppendLine($"                        // Write values inline using WriteRow (without the indent and newline)");
            sb.AppendLine($"                        {prop.ObjectGeneratedNamespace}.{prop.ObjectSafePropertyName}TonlSerializer.WriteRowInline(ref writer, {access});");
            sb.AppendLine("                    }");
            sb.AppendLine("                    else");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        writer.WriteKeyNull(\"{prop.Name}\");");
            sb.AppendLine("                    }");
            sb.AppendLine("                }");
        }
        else
        {
            // Fallback for unknown types
            sb.AppendLine($"writer.WriteKeyValue(\"{prop.Name}\", {access}?.ToString() ?? \"\");");
        }
    }

    private static void GenerateMetadata(StringBuilder sb, SerializableTypeInfo type, string indent)
    {
        // Only generate CreateObject for types that can be instantiated with new T()
        // Skip for: records, interfaces, abstract classes, primitives, types without parameterless constructor,
        // and types with init-only or required properties (since those require object initializer syntax)
        if (type.CanInstantiate && !type.IsRecord && !type.HasInitOnlyProperties)
        {
            sb.AppendLine($"{indent}            CreateObject = static () => new {type.FullyQualifiedName}(),");
        }

        sb.AppendLine($"{indent}            Properties = new TonlPropertyInfo<{type.FullyQualifiedName}>[]");
        sb.AppendLine($"{indent}            {{");

        for (int i = 0; i < type.Properties.Length; i++)
        {
            var prop = type.Properties[i];
            var comma = i < type.Properties.Length - 1 ? "," : "";

            sb.AppendLine($"{indent}                new TonlPropertyInfo<{type.FullyQualifiedName}>");
            sb.AppendLine($"{indent}                {{");
            sb.AppendLine($"{indent}                    Name = \"{prop.Name}\",");
            sb.AppendLine($"{indent}                    PropertyType = typeof({prop.TypeName}),");
            sb.AppendLine($"{indent}                    IsNullable = {(prop.IsNullable ? "true" : "false")},");
            sb.AppendLine($"{indent}                    GetValue = static obj => obj.{prop.Name},");

            // Skip SetValue for:
            // - Records (init-only via primary constructor)
            // - Init-only properties (can only be set in object initializer)
            // - Required properties (must be set in object initializer)
            // - Properties without public setter
            if (prop.HasPublicSetter && !type.IsRecord && !prop.IsInitOnly && !prop.IsRequired)
            {
                var setter = GetPropertySetter(prop);
                sb.AppendLine($"{indent}                    SetValue = static (obj, val) => obj.{prop.Name} = {setter},");
            }

            sb.AppendLine($"{indent}                }}{comma}");
        }

        sb.AppendLine($"{indent}            }},");
    }

    private static string GetPropertySetter(PropertyInfo prop)
    {
        return prop.Category switch
        {
            PropertyCategory.Boolean => "val is bool b ? b : default",
            PropertyCategory.Integer => GetNumericSetter(prop.TypeName),
            PropertyCategory.Float => GetNumericSetter(prop.TypeName),
            PropertyCategory.Decimal => "val is decimal d ? d : Convert.ToDecimal(val)",
            PropertyCategory.String => prop.IsNullable ? "val as string" : "(val as string)!",
            PropertyCategory.DateTime => GetDateTimeSetter(prop.TypeName, prop.IsNullable),
            PropertyCategory.Guid => "val is string s ? Guid.Parse(s) : (Guid)(val ?? default(Guid))",
            PropertyCategory.TimeSpan => "val is string s ? TimeSpan.Parse(s) : (TimeSpan)(val ?? default(TimeSpan))",
            PropertyCategory.Enum => $"({prop.TypeName})(val is long l ? l : (val is int i ? i : Convert.ToInt64(val)))",
            _ => $"({prop.TypeName})val!"
        };
    }

    private static string GetNumericSetter(string typeName)
    {
        var convertMethod = typeName switch
        {
            "global::System.Int32" or "int" => "ToInt32",
            "global::System.Int64" or "long" => "ToInt64",
            "global::System.Double" or "double" => "ToDouble",
            "global::System.Single" or "float" => "ToSingle",
            "global::System.Decimal" or "decimal" => "ToDecimal",
            "global::System.Int16" or "short" => "ToInt16",
            "global::System.Byte" or "byte" => "ToByte",
            "global::System.SByte" or "sbyte" => "ToSByte",
            "global::System.UInt16" or "ushort" => "ToUInt16",
            "global::System.UInt32" or "uint" => "ToUInt32",
            "global::System.UInt64" or "ulong" => "ToUInt64",
            _ => "ToInt32"
        };

        return $"Convert.{convertMethod}(val)";
    }

    private static string GetDateTimeSetter(string typeName, bool isNullable)
    {
        var parseMethod = typeName.Contains("DateTimeOffset") ? "DateTimeOffset.Parse" : "DateTime.Parse";
        if (isNullable)
            return $"val is string s ? {parseMethod}(s) : null";
        return $"{parseMethod}((val as string)!)";
    }
}
